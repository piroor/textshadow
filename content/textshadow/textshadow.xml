<?xml version="1.0"?>
<bindings id="textshadowBindings"
	xmlns="http://www.mozilla.org/xbl"
	xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
	xmlns:xbl="http://www.mozilla.org/xbl"
	xmlns:html="http://www.w3.org/1999/xhtml">

<binding id="textshadow-box">
	<content><html:_moz-textshadow-inner-box><html:_moz-textshadow-original/><html:_moz-textshadow-base><children/></html:_moz-textshadow-base></html:_moz-textshadow-inner-box></content>
	<implementation>
		<constructor><![CDATA[
			this.innerBox.setAttribute('style',
				'position: relative !important;'
				+ 'top: 0 !important;'
				+ 'left: 0 !important;'
			);
			this.baseBox.setAttribute('style',
				'position: absolute !important;'
				+ 'visibility: hidden !important;'
			);
			var d = document;
			var nodes = this.childNodes;
			var f = d.createDocumentFragment();
			for (var i = 0, maxi = nodes.length; i < maxi; i++)
			{
				f.appendChild(nodes[i].cloneNode(true));
			}
			this.originalBox.appendChild(f);
		]]></constructor>
		<field name="XHTMLNS">'http://www.w3.org/1999/xhtml'</field>

		<field name="innerBox" readonly="true">
			document.getAnonymousNodes(this)[0]
		</field>
		<field name="originalBox" readonly="true">
			document.getAnonymousNodes(this)[0].firstChild
		</field>
		<field name="baseBox" readonly="true">
			document.getAnonymousNodes(this)[0].lastChild
		</field>

		<field name="xOffset">0</field>
		<field name="yOffset">0</field>
		<field name="indent">0</field>
		<field name="width">0</field>
		<field name="boxWidth">0</field>
		<field name="boxHeight">0</field>
		<field name="renderingStyle">''</field>

		<field name="initialized">false</field>
		<method name="init">
			<parameter name="aPositionQuality"/>
			<body><![CDATA[
			this.initialized = true;
			var d = document;

			var info = this.getSizeBox();
			var parentBox = info.sizeBox;

			var context = window.getComputedStyle(this.parentNode, null).getPropertyValue('display');
			var originalBoxObject = d.getBoxObjectFor(context == 'inline' ? this.parentNode : this );
			var hasPreviousNode = d.evaluate('preceding-sibling::* | preceding-sibling::text()', this, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null).snapshotLength;
			if (context != 'inline' && hasPreviousNode)
				context = 'inline';

			switch (context)
			{
				case 'none':
					return;
				case 'inline':
					var lineHeight = this.getComputedPixels('line-height', this.parentNode);
					this.yOffset -= Math.round((lineHeight - this.getComputedPixels('font-size', this.parentNode)) / 2);
					var parentBoxObject = d.getBoxObjectFor(parentBox);
					if (originalBoxObject.height > lineHeight * 1.5) { // inlineÇ≈ê‹ÇËï‘Ç≥ÇÍÇƒÇ¢ÇÈèÍçá
						var delta = originalBoxObject.screenX - parentBoxObject.screenX - this.getComputedPixels('padding-left', parentBox);
						this.xOffset -= delta;
						info.indent += delta;
						info.width = info.boxWidth;
					}
					break;
				default:
					if ((aPositionQuality || 0) < 1) break;

					var dummy1 = d.createElementNS(this.XHTMLNS, '_moz-textbox-dummy-box');
					dummy1.appendChild(d.createTextNode('!'));
					var dummy2 = dummy1.cloneNode(true);
					dummy1.setAttribute('style', 'visibility: hidden; position: absolute; top: 0; left: 0;');
					dummy2.setAttribute('style', 'visibility: hidden;');

					var f = d.createDocumentFragment();
					f.appendChild(dummy1);
					f.appendChild(dummy2);
					this.innerBox.appendChild(f);
					this.yOffset += (d.getBoxObjectFor(dummy2).height - d.getBoxObjectFor(dummy1).height) / 2;
					this.innerBox.removeChild(dummy1);
					this.innerBox.removeChild(dummy2);
					break;
			}

			if (parentBox == this.parentNode && !hasPreviousNode)
				this.xOffset -= info.indent;

			if (window.getComputedStyle(parentBox, null).getPropertyValue('float') != 'none')
				this.yOffset += this.getComputedPixels('margin-top', parentBox);

			this.indent = info.indent;
			this.width = Math.min(info.width, info.boxWidth);
			this.boxWidth = info.boxWidth;
			this.boxHeight = info.boxHeight;

			this.renderingStyle = 'position: absolute !important; display: block !important;'
				+ 'margin: 0 !important; padding: 0 !important;'
				+ 'text-indent: '+this.indent+'px !important;'
				+ 'width: ' + this.width + 'px !important;';

			this.originalBox.setAttribute('style',
				'visibility: hidden !important;'
				+ '-moz-user-select: -moz-none !important;'
				+ '-moz-user-focus: ignore !important;'
			);

			this.baseBox.setAttribute('style', this.renderingStyle
					+ 'z-index: 2 !important;'
					+ 'top: ' + this.yOffset + 'px !important;'
					+ 'bottom: ' + (-this.yOffset) + 'px !important;'
					+ 'left: ' + this.xOffset + 'px !important;'
					+ 'right: ' + (-this.xOffset) + 'px !important;');

			]]></body>
		</method>

		<method name="clear">
			<body><![CDATA[
			var nodes = this.childNodes;
			var f = document.createDocumentFragment();
			for (var i = 0, maxi = nodes.length; i < maxi; i++)
			{
				f.appendChild(nodes[i].cloneNode(true));
			}
			this.parentNode.insertBefore(f, this);
			this.parentNode.removeChild(this);
			]]></body>
		</method>

		<method name="drawShadow">
			<parameter name="aX"/>
			<parameter name="aY"/>
			<parameter name="aRadius"/>
			<parameter name="aColor"/>
			<parameter name="aPositionQuality"/>
			<body><![CDATA[
			if ((!aX && !aY && !aRadius) || (aColor || '').toLowerCase() == 'transparent') {
				this.clear();
				return;
			}

			if (!this.initialized) this.init(aPositionQuality);

			var d = document;

			var color  = aColor || window.getComputedStyle(this, null).getPropertyValue('color');
			var x      = this.convertToPixels((aX || 0), this.boxWidth);
			var y      = this.convertToPixels((aY || 0), this.boxHeight);
			var radius = this.convertToPixels((aRadius || 0), this.boxWidth);

			var quality = 0;
			var gap;
			do {
				gap = quality;
				quality++;
				radius = Math.max(Math.max(radius, 1) / quality, 1);
			}
			while (radius != 1 && (radius * radius) > 30)

			if (radius != 1) radius *= 1.2; // to show like Safari

			var opacity = 1 / radius;
			if (radius != 1) opacity *= 0.35; // to show like Safari

			var shadows = d.createElementNS(this.XHTMLNS, '_moz-textshadow-shadow');
			shadows.setAttribute('style', this.renderingStyle
				+ 'z-index: 1 !important;'
				+ 'top: ' + (this.yOffset+y-(radius / 2)) + 'px !important;'
				+ 'bottom: ' + (-(this.yOffset+y-(radius / 2))) + 'px !important;'
				+ 'left: ' + (this.xOffset+x-(radius / 2)) + 'px !important;'
				+ 'right: ' + (-(this.xOffset+x-(radius / 2))) + 'px !important;'
				+ '-moz-user-select: -moz-none !important;'
				+ '-moz-user-focus: ignore !important;'
				+ 'text-decoration: none !important;'
				+ 'color: ' + color + ' !important;'
			);

			var nodes = this.childNodes;
			var part = d.createElementNS(this.XHTMLNS, '_moz-textshadow-shadow-part');
			for (var i = 0, maxi = radius; i < maxi; i++)
			{
				for (var j = 0, maxj = radius; j < maxj; j++)
				{
					var shadow = part.cloneNode(true);
					var f = d.createDocumentFragment();
					for (var k = 0, maxk = nodes.length; k < maxk; k++)
					{
						f.appendChild(nodes[k].cloneNode(true));
					}
					shadow.appendChild(f);
					shadow.setAttribute('style',
						'position: absolute !important; display: block !important;'
						+ 'margin: 0 !important; padding: 0 !important; text-indent: inherit !important;'
						+ 'opacity: ' + opacity + ' !important;'
						+ 'top: ' + (i+gap) + 'px !important;'
						+ 'bottom: ' + (-i-gap) + 'px !important;'
						+ 'left: ' + (j+gap) + 'px !important;'
						+ 'right: ' + (-j-gap) + 'px !important;'
					);
					shadows.appendChild(shadow);
				}
			}

			this.innerBox.appendChild(shadows);
			]]></body>
		</method>

		<method name="getSizeBox">
			<body><![CDATA[
			var d = document;
			var w = window;
			var box = this;
			var display;
			while (!/^table-|block|-moz-box/.test(display = w.getComputedStyle(box, null).getPropertyValue('display')) && box.parentNode)
			{
				box = box.parentNode;
			}
			if (box == d) box = d.documentElement;
			return {
				sizeBox   : box,
				display   : display,
				indent    : this.getComputedPixels('text-indent', box),
				width     : d.getBoxObjectFor(this).width,
				height    : d.getBoxObjectFor(this).height,
				boxWidth  : d.getBoxObjectFor(box).width
						- this.getComputedPixels('padding-left', box)
						- this.getComputedPixels('padding-right', box),
				boxHeight : d.getBoxObjectFor(box).height
					- this.getComputedPixels('padding-top', box)
					- this.getComputedPixels('padding-bottom', box)
			};
			]]></body>
		</method>

		<method name="getComputedPixels">
			<parameter name="aProperty"/>
			<parameter name="aNode"/>
			<body><![CDATA[
			if (!aNode) aNode = this;
			var value = window.getComputedStyle(aNode, null).getPropertyValue(aProperty);

			// line-height
			if (value.toLowerCase() == 'normal') return this.getComputedPixels('font-size', aNode) * 1.2;

			return Number(value.match(/^[-0-9\.]+/));
			]]></body>
		</method>

		<method name="convertToPixels">
			<parameter name="aCSSLength"/>
			<parameter name="aParentWidth"/>
			<parameter name="aTargetNode"/>
			<body><![CDATA[
			if (!aCSSLength || typeof aCSSLength == 'number')
				return aCSSLength;

			if (!aTargetNode) aTargetNode = this;

			var w = window;
			var fontSize = this.getComputedPixels('font-size', aTargetNode);
			var unit = aCSSLength.match(/em|ex|px|\%|mm|cm|in|pt|pc/i);
			var dpi = 72; // âÊñ âëúìxÇÕ72dpiÇ∆Ç›Ç»Ç∑
			if (unit) {
				aCSSLength = Number(aCSSLength.match(/^[-0-9\.]+/));
				switch (String(unit).toLowerCase())
				{
					case 'px':
						return aCSSLength;

					case '%':
						return aCSSLength / 100 * aParentWidth;

					case 'em':
						return aCSSLength * fontSize * 0.7;

					case 'ex':
						return aCSSLength * fontSize * 0.5;

					case 'in':
						return aCSSLength * dpi;
						break;

					case 'pt':
						return aCSSLength;
						break;
					case 'pc':
						return aCSSLength * 12;
						break;

					case 'mm':
						return aCSSLength * dpi * 0.03937;
						break;
					case 'cm':
						return aCSSLength * dpi * 0.3937;
						break;
				}
			}

			return 0;
			]]></body>
		</method>

	</implementation>
</binding>

</bindings>
